# Epic 2 Deferred Items (A-006 + A-008) Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Resolve two deferred retro items: standardize TeamEndpoints to use EndpointGroupBase (A-006), and add integration tests for CustomExceptionHandler mappings (A-008).

**Architecture:** A-006 is a pure refactor — convert static extension method pattern to the canonical EndpointGroupBase inheritance pattern used by RecruitmentEndpoints. A-008 adds functional tests that register test-only endpoints that throw specific exceptions, verifying the middleware returns correct HTTP status codes and Problem Details shapes.

**Tech Stack:** ASP.NET Core Minimal APIs, NUnit, FluentAssertions, WebApplicationFactory

---

## Testing Modes

- **A-006:** Characterization mode — existing functionality, no tests. Build passes and existing endpoint tests still work after refactor.
- **A-008:** Test-first mode — writing new integration tests for existing exception handler behavior.

## Authorization

Not applicable — A-006 changes endpoint registration only (no handlers). A-008 is test-only.

---

### Task 1: A-006 — Convert TeamEndpoints to EndpointGroupBase

**Files:**
- Modify: `api/src/Web/Endpoints/TeamEndpoints.cs`
- Modify: `api/src/Web/Program.cs` (remove `app.MapTeamEndpoints()`)

**Context:**
- The `WebApplicationExtensions.MapEndpoints()` discovers all `EndpointGroupBase` subclasses via reflection and registers them under `/api/{GroupName}`.
- A fallback authorization policy (`SetFallbackPolicy` with `RequireAuthenticatedUser`) exists in `DependencyInjection.cs`, so explicit `.RequireAuthorization()` is not needed.
- Current routes:
  - `GET /api/recruitments/{recruitmentId:guid}/members`
  - `GET /api/recruitments/{recruitmentId:guid}/directory-search`
  - `POST /api/recruitments/{recruitmentId:guid}/members`
  - `DELETE /api/recruitments/{recruitmentId:guid}/members/{memberId:guid}`
- The common group prefix is `recruitments/{recruitmentId:guid}` — but this would produce a tag collision with `RecruitmentEndpoints` (GroupName `"recruitments"`). Instead, we use a dedicated GroupName to keep tags distinct.
- Use GroupName `"team"` with full route paths in Map() that include the recruitment prefix. This keeps the tag clean as "team" while producing correct URLs.

Wait — `MapGroup` in `WebApplicationExtensions` does `app.MapGroup($"/api/{groupName}")`. If GroupName is `"team"`, routes would be at `/api/team/members` etc., which is WRONG. The routes must stay at `/api/recruitments/{recruitmentId:guid}/members`.

Correct approach: GroupName must encode the full path prefix. Set it to `"recruitments/{recruitmentId:guid}"` and map routes as `/members`, `/directory-search`, `/members/{memberId:guid}`. The tag will be `"recruitments/{recruitmentId:guid}"` which is ugly but functionally correct and matches what the api-patterns.md shows for nested resources.

Actually, looking at api-patterns.md canonical example:
```csharp
public override string? GroupName => "recruitments/{recruitmentId:guid}/members";
```

But that doesn't work for `/directory-search`. The cleanest split: keep GroupName as the recruitment sub-path and put all team routes under it.

**Decision:** Use GroupName `"recruitments/{recruitmentId:guid}"` so the group maps to `/api/recruitments/{recruitmentId:guid}`. Route `/members`, `/directory-search`, `/members/{memberId:guid}` under it. Override `.WithTags("team")` by calling it on each route or using group filter.

Actually, the `WebApplicationExtensions.MapGroup()` already calls `.WithTags(groupName)`. We can't override the tag without changing the extension. The tag will be the GroupName. This is acceptable — tags are just for OpenAPI grouping. Let's keep it simple.

**Step 1: Rewrite TeamEndpoints.cs**

Replace the static class with an EndpointGroupBase subclass:

```csharp
using api.Application.Features.Team.Commands.AddMember;
using api.Application.Features.Team.Commands.RemoveMember;
using api.Application.Features.Team.Queries.GetMembers;
using api.Application.Features.Team.Queries.SearchDirectory;
using api.Web.Infrastructure;
using MediatR;

namespace api.Web.Endpoints;

public class TeamEndpoints : EndpointGroupBase
{
    public override string? GroupName => "recruitments/{recruitmentId:guid}";

    public override void Map(RouteGroupBuilder group)
    {
        group.MapGet("/members", GetMembers);
        group.MapGet("/directory-search", SearchDirectory);
        group.MapPost("/members", AddMember);
        group.MapDelete("/members/{memberId:guid}", RemoveMember);
    }

    private static async Task<IResult> GetMembers(
        ISender sender,
        Guid recruitmentId)
    {
        var result = await sender.Send(new GetMembersQuery { RecruitmentId = recruitmentId });
        return Results.Ok(result);
    }

    private static async Task<IResult> SearchDirectory(
        ISender sender,
        Guid recruitmentId,
        string q)
    {
        var result = await sender.Send(new SearchDirectoryQuery { SearchTerm = q });
        return Results.Ok(result);
    }

    private static async Task<IResult> AddMember(
        ISender sender,
        Guid recruitmentId,
        AddMemberCommand command)
    {
        var memberId = await sender.Send(command with { RecruitmentId = recruitmentId });
        return Results.Created(
            $"/api/recruitments/{recruitmentId}/members/{memberId}",
            new { id = memberId });
    }

    private static async Task<IResult> RemoveMember(
        ISender sender,
        Guid recruitmentId,
        Guid memberId)
    {
        await sender.Send(new RemoveMemberCommand { RecruitmentId = recruitmentId, MemberId = memberId });
        return Results.NoContent();
    }
}
```

**Step 2: Remove manual registration from Program.cs**

Remove the `app.MapTeamEndpoints();` line and the `using api.Web.Endpoints;` import (if no longer needed — check if other usings require it).

**Step 3: Build and verify**

Run: `dotnet build api/src/Web/Web.csproj`
Expected: Build succeeds with no errors.

**Step 4: Run existing tests**

Run: `dotnet test api/tests/Application.FunctionalTests/`
Expected: All existing tests pass.

**Step 5: Commit**

```bash
git add api/src/Web/Endpoints/TeamEndpoints.cs api/src/Web/Program.cs
git commit -m "refactor(A-006): convert TeamEndpoints to EndpointGroupBase pattern"
```

---

### Task 2: A-008 — Add integration tests for CustomExceptionHandler

**Files:**
- Create: `api/tests/Application.FunctionalTests/Infrastructure/CustomExceptionHandlerTests.cs`

**Context:**
- The `CustomExceptionHandler` maps 8 exception types to HTTP status codes and Problem Details.
- Testing approach: Create a lightweight `WebApplicationFactory` that registers test-only endpoints, each throwing a specific exception. Then verify the HTTP response.
- No database needed — these tests exercise the middleware pipeline only.
- Use NUnit `[Test]` and FluentAssertions per project standards.
- The factory runs in Development mode so dev auth handler is active — add dev auth headers to requests.

**Exception Mappings to Test:**

| Exception | Expected Status | Expected Title |
|-----------|----------------|----------------|
| `ValidationException` | 400 | `One or more validation errors occurred.` |
| `NotFoundException` | 404 | `The specified resource was not found.` |
| `ForbiddenAccessException` | 403 | `Forbidden` |
| `RecruitmentClosedException` | 400 | `Recruitment is closed` |
| `DomainRuleViolationException` | 400 | `Domain rule violation` |
| `StepHasOutcomesException` | 409 | `Cannot remove -- outcomes recorded at this step` |
| `DuplicateStepNameException` | 409 | `Duplicate step name` |
| `UnauthorizedAccessException` | 401 | `Unauthorized` |

**Step 1: Write the test file**

```csharp
using System.Net;
using System.Net.Http.Json;
using api.Application.Common.Exceptions;
using api.Domain.Exceptions;
using FluentAssertions;
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Mvc.Testing;

namespace api.Application.FunctionalTests.Infrastructure;

[TestFixture]
public class CustomExceptionHandlerTests
{
    private WebApplicationFactory<Program> _factory = null!;
    private HttpClient _client = null!;

    [SetUp]
    public void SetUp()
    {
        _factory = new WebApplicationFactory<Program>()
            .WithWebHostBuilder(builder =>
            {
                builder.UseEnvironment("Development");
                builder.UseSetting("ConnectionStrings:apiDb",
                    "Server=(localdb)\\mssqllocaldb;Database=apiTestDb;Trusted_Connection=True");
                builder.ConfigureServices(services =>
                {
                    // Register test-only endpoints that throw specific exceptions
                    services.AddSingleton<IStartupFilter>(new TestExceptionEndpointsStartupFilter());
                });
            });

        _client = _factory.CreateClient();
        _client.DefaultRequestHeaders.Add("X-Dev-User-Id", "test-user");
        _client.DefaultRequestHeaders.Add("X-Dev-User-Name", "Test User");
    }

    [TearDown]
    public void TearDown()
    {
        _client.Dispose();
        _factory.Dispose();
    }

    [Test]
    public async Task ValidationException_Returns400WithProblemDetails()
    {
        var response = await _client.GetAsync("/api/test-exceptions/validation");

        response.StatusCode.Should().Be(HttpStatusCode.BadRequest);
        var problem = await response.Content.ReadFromJsonAsync<ValidationProblemDetails>();
        problem.Should().NotBeNull();
        problem!.Status.Should().Be(400);
        problem.Errors.Should().ContainKey("Name");
    }

    [Test]
    public async Task NotFoundException_Returns404WithProblemDetails()
    {
        var response = await _client.GetAsync("/api/test-exceptions/not-found");

        response.StatusCode.Should().Be(HttpStatusCode.NotFound);
        var problem = await response.Content.ReadFromJsonAsync<ProblemDetails>();
        problem.Should().NotBeNull();
        problem!.Status.Should().Be(404);
        problem.Title.Should().Be("The specified resource was not found.");
    }

    [Test]
    public async Task ForbiddenAccessException_Returns403WithProblemDetails()
    {
        var response = await _client.GetAsync("/api/test-exceptions/forbidden");

        response.StatusCode.Should().Be(HttpStatusCode.Forbidden);
        var problem = await response.Content.ReadFromJsonAsync<ProblemDetails>();
        problem.Should().NotBeNull();
        problem!.Status.Should().Be(403);
        problem.Title.Should().Be("Forbidden");
    }

    [Test]
    public async Task RecruitmentClosedException_Returns400WithProblemDetails()
    {
        var response = await _client.GetAsync("/api/test-exceptions/recruitment-closed");

        response.StatusCode.Should().Be(HttpStatusCode.BadRequest);
        var problem = await response.Content.ReadFromJsonAsync<ProblemDetails>();
        problem.Should().NotBeNull();
        problem!.Status.Should().Be(400);
        problem.Title.Should().Be("Recruitment is closed");
    }

    [Test]
    public async Task DomainRuleViolationException_Returns400WithProblemDetails()
    {
        var response = await _client.GetAsync("/api/test-exceptions/domain-rule-violation");

        response.StatusCode.Should().Be(HttpStatusCode.BadRequest);
        var problem = await response.Content.ReadFromJsonAsync<ProblemDetails>();
        problem.Should().NotBeNull();
        problem!.Status.Should().Be(400);
        problem.Title.Should().Be("Domain rule violation");
    }

    [Test]
    public async Task StepHasOutcomesException_Returns409WithProblemDetails()
    {
        var response = await _client.GetAsync("/api/test-exceptions/step-has-outcomes");

        response.StatusCode.Should().Be(HttpStatusCode.Conflict);
        var problem = await response.Content.ReadFromJsonAsync<ProblemDetails>();
        problem.Should().NotBeNull();
        problem!.Status.Should().Be(409);
        problem.Title.Should().Be("Cannot remove -- outcomes recorded at this step");
    }

    [Test]
    public async Task DuplicateStepNameException_Returns409WithProblemDetails()
    {
        var response = await _client.GetAsync("/api/test-exceptions/duplicate-step-name");

        response.StatusCode.Should().Be(HttpStatusCode.Conflict);
        var problem = await response.Content.ReadFromJsonAsync<ProblemDetails>();
        problem.Should().NotBeNull();
        problem!.Status.Should().Be(409);
        problem.Title.Should().Be("Duplicate step name");
    }

    [Test]
    public async Task UnauthorizedAccessException_Returns401WithProblemDetails()
    {
        var response = await _client.GetAsync("/api/test-exceptions/unauthorized");

        response.StatusCode.Should().Be(HttpStatusCode.Unauthorized);
        var problem = await response.Content.ReadFromJsonAsync<ProblemDetails>();
        problem.Should().NotBeNull();
        problem!.Status.Should().Be(401);
        problem.Title.Should().Be("Unauthorized");
    }

    /// <summary>
    /// Registers test-only endpoints that throw specific exceptions for testing the exception handler.
    /// </summary>
    private class TestExceptionEndpointsStartupFilter : IStartupFilter
    {
        public Action<IApplicationBuilder> Configure(Action<IApplicationBuilder> next)
        {
            return app =>
            {
                next(app);

                if (app is WebApplication webApp)
                {
                    var group = webApp.MapGroup("/api/test-exceptions");

                    group.MapGet("/validation", () =>
                    {
                        var failures = new List<FluentValidation.Results.ValidationFailure>
                        {
                            new("Name", "Name is required")
                        };
                        throw new ValidationException(failures);
                    });

                    group.MapGet("/not-found", () =>
                    {
                        throw new NotFoundException("TestEntity", "test-id");
                    });

                    group.MapGet("/forbidden", () =>
                    {
                        throw new ForbiddenAccessException();
                    });

                    group.MapGet("/recruitment-closed", () =>
                    {
                        throw new RecruitmentClosedException(Guid.NewGuid());
                    });

                    group.MapGet("/domain-rule-violation", () =>
                    {
                        throw new DomainRuleViolationException("Test domain rule violated");
                    });

                    group.MapGet("/step-has-outcomes", () =>
                    {
                        throw new StepHasOutcomesException(Guid.NewGuid(), "Test Step");
                    });

                    group.MapGet("/duplicate-step-name", () =>
                    {
                        throw new DuplicateStepNameException("Duplicate Name");
                    });

                    group.MapGet("/unauthorized", () =>
                    {
                        throw new UnauthorizedAccessException();
                    });
                }
            };
        }
    }
}
```

Note: The `IStartupFilter` approach registers endpoints AFTER the middleware pipeline is configured, so exception handler middleware is already in place. However, this might not work because `IStartupFilter` runs before `UseExceptionHandler` in the pipeline. A simpler approach may be needed — register endpoints in `ConfigureTestServices` or `Configure` callback.

**Alternative approach (simpler):** Use `WebApplicationFactory.WithWebHostBuilder` with a custom `Configure` that maps test endpoints after the app is built. Actually, the cleanest ASP.NET Core approach for this is to use `builder.ConfigureServices` to add a hosted service or use the `IEndpointRouteBuilder` directly.

The cleanest way: just add them in a test `IStartupFilter` or override the app's endpoint configuration. In practice for ASP.NET Core 8+, the `IStartupFilter` approach works if we cast to `IEndpointRouteBuilder`. But since `Program.cs` builds a `WebApplication`, we need the endpoints registered at the right time.

**Simplest reliable approach:** Add a test-only middleware that catches requests to `/api/test-exceptions/*` paths and throws the appropriate exception. This is simpler and doesn't require endpoint registration timing to be correct.

**Step 2: Build and run tests**

Run: `dotnet test api/tests/Application.FunctionalTests/ --filter "FullyQualifiedName~CustomExceptionHandler"`
Expected: All 8 tests pass.

**Step 3: Commit**

```bash
git add api/tests/Application.FunctionalTests/Infrastructure/CustomExceptionHandlerTests.cs
git commit -m "test(A-008): add integration tests for CustomExceptionHandler mappings"
```

---

### Task 3: Final verification

**Step 1: Run full test suite**

Run: `dotnet test api/tests/`
Expected: All tests pass.

**Step 2: Build check**

Run: `dotnet build api/`
Expected: Clean build with no warnings.
